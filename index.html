<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Novel - AI Story Engine</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }

        #neural-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .glass-panel {
            position: absolute;
            z-index: 2;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 16px;
            padding: 24px;
            animation: float 6s ease-in-out infinite;
            box-shadow: 0 8px 32px rgba(0, 100, 255, 0.1);
        }

        .glass-panel:nth-child(1) {
            top: 10%;
            left: 5%;
            width: 320px;
            animation-delay: 0s;
            border-top: 2px solid rgba(255, 100, 255, 0.3);
        }

        .glass-panel:nth-child(2) {
            top: 20%;
            right: 5%;
            width: 280px;
            animation-delay: 1s;
            border-top: 2px solid rgba(100, 255, 255, 0.3);
        }

        .glass-panel:nth-child(3) {
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            width: 350px;
            animation-delay: 2s;
            border-top: 2px solid rgba(255, 255, 100, 0.3);
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-20px); }
        }

        h1 {
            font-size: 36px;
            font-weight: 300;
            letter-spacing: 2px;
            margin-bottom: 12px;
            background: linear-gradient(90deg, #ff00ff, #00ffff, #ffff00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(255, 0, 255, 0.3);
        }

        .subtitle {
            font-size: 14px;
            font-weight: 400;
            letter-spacing: 6px;
            text-transform: uppercase;
            color: #88aaff;
            margin-bottom: 24px;
            text-shadow: 0 0 10px rgba(100, 200, 255, 0.3);
        }

        p {
            font-size: 14px;
            line-height: 1.6;
            color: #ccddee;
            margin-bottom: 20px;
        }

        .control-group {
            margin-top: 20px;
        }

        label {
            display: block;
            font-size: 12px;
            color: #aaccff;
            margin-bottom: 8px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        input[type="range"] {
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, #000, #224488);
            border-radius: 1px;
            outline: none;
            -webkit-appearance: none;
            margin-bottom: 16px;
            border: 1px solid rgba(100, 150, 255, 0.2);
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #00ffff;
            cursor: pointer;
            border: 2px solid #000;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
            transition: all 0.3s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #ff00ff;
            box-shadow: 0 0 15px rgba(255, 0, 255, 1);
        }

        .feature-list {
            list-style: none;
        }

        .feature-list li {
            position: relative;
            padding-left: 20px;
            margin-bottom: 10px;
            color: #bbddff;
            font-size: 13px;
        }

        .feature-list li:before {
            content: "▶";
            position: absolute;
            left: 0;
            color: #00ffff;
            font-size: 10px;
        }

        .stats {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 2;
            font-size: 11px;
            color: #6688aa;
            letter-spacing: 1px;
            text-align: right;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        .github-corner {
            position: fixed;
            top: 0;
            right: 0;
            z-index: 3;
            width: 80px;
            height: 80px;
            overflow: hidden;
        }

        .github-corner svg {
            fill: #00ffff;
            color: #000;
            position: absolute;
            top: 0;
            right: 0;
            border: 0;
            opacity: 0.5;
            transition: opacity 0.3s, fill 0.3s;
        }

        .github-corner:hover svg {
            opacity: 0.8;
            fill: #ff00ff;
        }

        .neuron {
            position: absolute;
            z-index: 2;
            width: 4px;
            height: 4px;
            background: rgba(0, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            filter: blur(1px);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .pulse {
            position: absolute;
            z-index: 1;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 0, 255, 0.1) 0%, rgba(255, 0, 255, 0) 70%);
            pointer-events: none;
            animation: pulse 3s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(0.5); opacity: 0.5; }
            50% { transform: scale(1); opacity: 0.2; }
            100% { transform: scale(0.5); opacity: 0.5; }
        }

        @media (max-width: 768px) {
            .glass-panel {
                width: 90% !important;
                left: 5% !important;
                right: 5% !important;
                transform: none !important;
                position: relative;
                margin: 20px auto;
            }
            
            .glass-panel:nth-child(1),
            .glass-panel:nth-child(2),
            .glass-panel:nth-child(3) {
                position: relative;
                top: auto;
                left: auto;
                right: auto;
                bottom: auto;
                transform: none;
                margin: 20px auto;
            }
            
            body {
                overflow-y: auto;
                padding: 20px;
            }
            
            h1 {
                font-size: 28px;
            }
        }
    </style>
</head>
<body>
    <canvas id="neural-canvas"></canvas>
    
    <div class="glass-panel">
        <h1>INFINITE NOVEL</h1>
        <div class="subtitle">AI STORY ENGINE</div>
        <p>An experimental AI-powered interactive storytelling engine that creates dynamic, evolving narratives in real-time. Experience the fusion of quantum neural networks, fractal memory, and emergent narrative systems.</p>
    </div>
    
    <div class="glass-panel">
        <div class="subtitle">NARRATIVE CONTROLS</div>
        <div class="control-group">
            <label>RESONANCE</label>
            <input type="range" id="resonance" min="0" max="2" value="1.0" step="0.1">
            
            <label>INSTABILITY</label>
            <input type="range" id="instability" min="0" max="2" value="0.5" step="0.1">
            
            <label>COLLAPSE RISK</label>
            <input type="range" id="collapse" min="0" max="2" value="0.3" step="0.1">
            
            <label>NARRATIVE FLOW</label>
            <input type="range" id="narrativeFlow" min="0.1" max="3" value="1.5" step="0.1">
        </div>
    </div>
    
    <div class="glass-panel">
        <div class="subtitle">CORE SYSTEMS</div>
        <ul class="feature-list">
            <li>Quantum Neural Network</li>
            <li>Fractal Memory System</li>
            <li>Dynamic Story Arcs</li>
            <li>Real-time AI Generation</li>
            <li>Emotional Intelligence</li>
            <li>Procedural Music</li>
            <li>Visual Morphing Pipeline</li>
            <li>Interactive World State</li>
        </ul>
    </div>
    
    <div class="stats">
        <div id="fps">FPS: 60</div>
        <div id="resolution">RES: 1920×1080</div>
        <div id="nodes">NEURONS: 0</div>
    </div>
    
    <a href="https://github.com/0penAGI/InfiniteNovel" class="github-corner" aria-label="View source on GitHub" target="_blank">
        <svg width="80" height="80" viewBox="0 0 250 250" style="fill:#00ffff; color:#000; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
            <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
            <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
            <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
        </svg>
    </a>

    <script>
        // WebGL Neural Network Shader
        const canvas = document.getElementById('neural-canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        
        if (!gl) {
            alert('WebGL not supported');
            throw new Error('WebGL not supported');
        }
        
        // Shader sources - Neural Network Simulation
        const vertexShaderSource = `
            attribute vec2 a_position;
            varying vec2 v_uv;
            
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                v_uv = a_position * 0.5 + 0.5;
            }
        `;
        
        const fragmentShaderSource = `
            precision highp float;
            
            varying vec2 v_uv;
            uniform float u_time;
            uniform float u_resonance;
            uniform float u_instability;
            uniform float u_collapse;
            uniform float u_narrative_flow;
            uniform vec2 u_mouse;
            uniform vec2 u_resolution;
            
            // Hash function for noise
            float hash(vec2 p) {
                p = fract(p * vec2(123.34, 456.21));
                p += dot(p, p + 45.32);
                return fract(p.x * p.y);
            }
            
            // Simplex noise
            float noise(vec2 p) {
                vec2 ip = floor(p);
                vec2 fp = fract(p);
                
                float a = hash(ip);
                float b = hash(ip + vec2(1.0, 0.0));
                float c = hash(ip + vec2(0.0, 1.0));
                float d = hash(ip + vec2(1.0, 1.0));
                
                vec2 t = smoothstep(0.0, 1.0, fp);
                
                return mix(mix(a, b, t.x), mix(c, d, t.x), t.y);
            }
            
            // Fractal Brownian Motion for neural patterns
            float fbm(vec2 p) {
                float value = 0.0;
                float amplitude = 0.5;
                float frequency = 1.0;
                
                for (int i = 0; i < 6; i++) {
                    value += amplitude * noise(p * frequency);
                    amplitude *= 0.5;
                    frequency *= 2.0;
                }
                
                return value;
            }
            
            // Neural network simulation
            vec3 neuralNetwork(vec2 p, float time) {
                vec3 color = vec3(0.0);
                
                // Base neural activity
                float activity = 0.0;
                
                // Multiple layers of neural activity
                for (int i = 0; i < 4; i++) {
                    float layer = float(i);
                    vec2 offset = vec2(sin(time * 0.2 + layer), cos(time * 0.3 + layer));
                    activity += fbm(p * (2.0 + layer) + offset) * (0.3 / (1.0 + layer));
                }
                
                // Apply resonance
                activity *= u_resonance;
                
                // Neural connections (sinusoidal patterns)
                float connections = 0.0;
                for (int i = 0; i < 3; i++) {
                    float freq = 5.0 + float(i) * 3.0;
                    connections += sin(p.x * freq + time * 0.5) * cos(p.y * freq + time * 0.3) * 0.2;
                }
                
                // Combine activity and connections
                float neural = activity + connections;
                
                // Apply instability for distortion
                vec2 distortedUV = p;
                distortedUV.x += sin(p.y * 3.0 + time * u_instability) * 0.1 * u_instability;
                distortedUV.y += cos(p.x * 2.0 + time * u_instability * 0.8) * 0.1 * u_instability;
                
                // Collapse effect - dark voids
                float collapseMask = 1.0;
                if (u_collapse > 0.5) {
                    vec2 collapseCenter = vec2(0.5, 0.5);
                    float collapseDist = distance(p, collapseCenter);
                    collapseMask = 1.0 - smoothstep(0.0, 0.5 * u_collapse, collapseDist);
                }
                
                // Color scheme for neural network
                // Base: deep space blue
                color = vec3(0.05, 0.08, 0.15);
                
                // Neural activity: cyan
                color += vec3(0.0, 0.7, 0.7) * neural * 0.8;
                
                // Hot spots: magenta
                float hotspots = fbm(distortedUV * 8.0 + time * 0.5);
                color += vec3(0.8, 0.0, 0.8) * hotspots * 0.3 * u_resonance;
                
                // Narrative flow: yellow pulses
                float flowPulse = sin(p.x * 10.0 + time * u_narrative_flow) * 
                                 cos(p.y * 8.0 + time * u_narrative_flow * 0.7) * 0.1;
                color += vec3(0.8, 0.8, 0.0) * flowPulse * u_narrative_flow;
                
                // Apply collapse effect
                color *= collapseMask;
                
                // Mouse interaction - neural activation
                vec2 mouseDist = p - u_mouse;
                float mouseInfluence = exp(-length(mouseDist) * 15.0) * 2.0;
                color += vec3(0.0, 1.0, 1.0) * mouseInfluence * u_resonance;
                
                return color;
            }
            
            // Main shader
            void main() {
                vec2 uv = v_uv;
                vec2 p = uv * 2.0 - 1.0;
                p.x *= u_resolution.x / u_resolution.y;
                
                // Time with narrative flow
                float time = u_time * 0.001 * u_narrative_flow;
                
                // Generate neural network visualization
                vec3 color = neuralNetwork(p, time);
                
                // Edge vignette
                float vignette = 1.0 - length(p) * 0.3;
                color *= vignette;
                
                // Final output
                gl_FragColor = vec4(color, 1.0);
            }
        `;
        
        // Compile shader
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }
        
        // Create shader program
        const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
        
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program linking error:', gl.getProgramInfoLog(program));
        }
        
        gl.useProgram(program);
        
        // Create fullscreen quad
        const vertices = new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
             1,  1
        ]);
        
        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        
        const positionAttrib = gl.getAttribLocation(program, 'a_position');
        gl.enableVertexAttribArray(positionAttrib);
        gl.vertexAttribPointer(positionAttrib, 2, gl.FLOAT, false, 0, 0);
        
        // Get uniform locations
        const timeUniform = gl.getUniformLocation(program, 'u_time');
        const resonanceUniform = gl.getUniformLocation(program, 'u_resonance');
        const instabilityUniform = gl.getUniformLocation(program, 'u_instability');
        const collapseUniform = gl.getUniformLocation(program, 'u_collapse');
        const narrativeFlowUniform = gl.getUniformLocation(program, 'u_narrative_flow');
        const mouseUniform = gl.getUniformLocation(program, 'u_mouse');
        const resolutionUniform = gl.getUniformLocation(program, 'u_resolution');
        
        // Set initial uniform values
        const uniforms = {
            resonance: 1.0,
            instability: 0.5,
            collapse: 0.3,
            narrativeFlow: 1.5,
            mouse: [0.5, 0.5]
        };
        
        // Update uniforms from UI
        function updateUniforms() {
            gl.uniform1f(resonanceUniform, uniforms.resonance);
            gl.uniform1f(instabilityUniform, uniforms.instability);
            gl.uniform1f(collapseUniform, uniforms.collapse);
            gl.uniform1f(narrativeFlowUniform, uniforms.narrativeFlow);
            gl.uniform2f(mouseUniform, uniforms.mouse[0], uniforms.mouse[1]);
        }
        
        // Resize canvas
        function resizeCanvas() {
            const displayWidth = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
                gl.uniform2f(resolutionUniform, canvas.width, canvas.height);
                
                // Update stats
                document.getElementById('resolution').textContent = 
                    `RES: ${canvas.width}×${canvas.height}`;
            }
        }
        
        window.addEventListener('resize', resizeCanvas);
        
        // Mouse interaction
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            uniforms.mouse[0] = (e.clientX - rect.left) / canvas.width;
            uniforms.mouse[1] = 1.0 - (e.clientY - rect.top) / canvas.height;
            
            // Create neural activation at mouse position
            createNeuronActivation(e.clientX, e.clientY);
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            uniforms.mouse[0] = (e.touches[0].clientX - rect.left) / canvas.width;
            uniforms.mouse[1] = 1.0 - (e.touches[0].clientY - rect.top) / canvas.height;
            
            // Create neural activation at touch position
            createNeuronActivation(e.touches[0].clientX, e.touches[0].clientY);
        });
        
        // UI controls
        document.getElementById('resonance').addEventListener('input', (e) => {
            uniforms.resonance = parseFloat(e.target.value);
            updateUniforms();
        });
        
        document.getElementById('instability').addEventListener('input', (e) => {
            uniforms.instability = parseFloat(e.target.value);
            updateUniforms();
        });
        
        document.getElementById('collapse').addEventListener('input', (e) => {
            uniforms.collapse = parseFloat(e.target.value);
            updateUniforms();
        });
        
        document.getElementById('narrativeFlow').addEventListener('input', (e) => {
            uniforms.narrativeFlow = parseFloat(e.target.value);
            updateUniforms();
        });
        
        // Create neural particles
        function createNeuronParticles() {
            const particles = [];
            
            for (let i = 0; i < 50; i++) {
                const particle = document.createElement('div');
                particle.className = 'neuron';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.top = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 5 + 's';
                document.body.appendChild(particle);
                
                particles.push({
                    element: particle,
                    x: Math.random() * window.innerWidth,
                    y: Math.random() * window.innerHeight,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5
                });
            }
            
            return particles;
        }
        
        // Create neural activation effect
        function createNeuronActivation(x, y) {
            const activation = document.createElement('div');
            activation.className = 'pulse';
            activation.style.left = (x - 50) + 'px';
            activation.style.top = (y - 50) + 'px';
            document.body.appendChild(activation);
            
            setTimeout(() => {
                activation.remove();
            }, 3000);
            
            // Update neuron count
            const neuronCount = document.querySelectorAll('.neuron').length;
            document.getElementById('nodes').textContent = `NEURONS: ${neuronCount}`;
        }
        
        // Create initial neural particles
        const particles = createNeuronParticles();
        
        // Animate neural particles
        function animateParticles() {
            particles.forEach(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                
                // Bounce off walls
                if (particle.x < 0 || particle.x > window.innerWidth) particle.vx *= -1;
                if (particle.y < 0 || particle.y > window.innerHeight) particle.vy *= -1;
                
                // Apply some randomness
                particle.vx += (Math.random() - 0.5) * 0.02;
                particle.vy += (Math.random() - 0.5) * 0.02;
                
                // Limit velocity
                const speed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
                if (speed > 1) {
                    particle.vx = particle.vx / speed;
                    particle.vy = particle.vy / speed;
                }
                
                particle.element.style.left = particle.x + 'px';
                particle.element.style.top = particle.y + 'px';
                
                // Pulsing effect
                const pulse = Math.sin(Date.now() * 0.002 + particle.x * 0.01) * 0.5 + 0.5;
                particle.element.style.opacity = 0.3 + pulse * 0.5;
            });
            
            requestAnimationFrame(animateParticles);
        }
        
        // FPS counter
        let fps = 60;
        let lastTime = performance.now();
        let frameCount = 0;
        
        // Animation loop
        function animate(currentTime) {
            frameCount++;
            
            if (currentTime - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = currentTime;
                document.getElementById('fps').textContent = `FPS: ${fps}`;
            }
            
            resizeCanvas();
            gl.uniform1f(timeUniform, currentTime);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            requestAnimationFrame(animate);
        }
        
        // Initialize
        resizeCanvas();
        updateUniforms();
        animateParticles();
        
        // Start animation
        requestAnimationFrame(animate);
        
        // Prevent context menu on right click
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        
        // Create initial neural network pulses
        setInterval(() => {
            const x = Math.random() * window.innerWidth;
            const y = Math.random() * window.innerHeight;
            createNeuronActivation(x, y);
        }, 2000);
    </script>
</body>
</html>
