<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Novel - WebGL Experience</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            color: #fff;
            overflow-x: hidden;
            line-height: 1.6;
        }

        .container {
            position: relative;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #webgl-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }

        .content {
            position: relative;
            z-index: 2;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 60px 20px 40px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            margin-bottom: 40px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 100, 255, 0.2);
        }

        h1 {
            font-size: 4rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #ff00ff, #00ffff, #ffff00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 1.5rem;
            color: #a0a0ff;
            margin-bottom: 30px;
            font-weight: 300;
        }

        .github-link {
            display: inline-block;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 12px 30px;
            border-radius: 30px;
            text-decoration: none;
            font-size: 1.1rem;
            margin-top: 20px;
            transition: all 0.3s;
            border: 1px solid #00ffff;
        }

        .github-link:hover {
            background: rgba(0, 150, 255, 0.3);
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 200, 255, 0.4);
        }

        .github-link i {
            margin-right: 10px;
        }

        .description {
            background: rgba(0, 0, 30, 0.8);
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 40px;
            border-left: 5px solid #ff00ff;
            backdrop-filter: blur(5px);
        }

        .description h2 {
            color: #00ffff;
            margin-bottom: 15px;
            font-size: 1.8rem;
        }

        .features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin-bottom: 40px;
        }

        .feature-card {
            background: rgba(20, 10, 40, 0.7);
            padding: 25px;
            border-radius: 15px;
            border: 1px solid rgba(100, 100, 255, 0.2);
            transition: transform 0.3s;
            backdrop-filter: blur(5px);
        }

        .feature-card:hover {
            transform: translateY(-5px);
            border-color: #ff00ff;
        }

        .feature-card h3 {
            color: #ffff00;
            margin-bottom: 15px;
            font-size: 1.4rem;
            display: flex;
            align-items: center;
        }

        .feature-card h3 i {
            margin-right: 10px;
            color: #00ffff;
        }

        .tech-stack {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 20px;
        }

        .tech-tag {
            background: rgba(0, 100, 255, 0.2);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            border: 1px solid rgba(0, 200, 255, 0.3);
        }

        .code-preview {
            background: rgba(0, 0, 0, 0.8);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 40px;
            border: 1px solid rgba(255, 0, 255, 0.3);
            font-family: 'Courier New', monospace;
            overflow-x: auto;
        }

        .code-preview h2 {
            color: #ffff00;
            margin-bottom: 15px;
            font-size: 1.8rem;
        }

        .code-snippet {
            color: #a0ffa0;
            line-height: 1.5;
            font-size: 0.95rem;
        }

        .code-comment {
            color: #808080;
        }

        .code-keyword {
            color: #ff8080;
        }

        .code-string {
            color: #ffa0a0;
        }

        .shader-controls {
            background: rgba(10, 0, 30, 0.8);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 40px;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }

        .shader-controls h2 {
            color: #00ffff;
            margin-bottom: 20px;
            font-size: 1.8rem;
        }

        .control-group {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }

        .control-item {
            flex: 1;
            min-width: 200px;
        }

        .control-item label {
            display: block;
            margin-bottom: 8px;
            color: #a0a0ff;
        }

        .control-item input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(100, 100, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        .control-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ff00ff;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.8);
        }

        .preset-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
        }

        .preset-btn {
            background: rgba(0, 50, 150, 0.5);
            color: white;
            border: 1px solid rgba(0, 200, 255, 0.5);
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .preset-btn:hover {
            background: rgba(0, 100, 255, 0.7);
            transform: translateY(-2px);
        }

        footer {
            text-align: center;
            padding: 30px;
            color: #8080ff;
            border-top: 1px solid rgba(100, 100, 255, 0.2);
            margin-top: 40px;
            background: rgba(0, 0, 20, 0.8);
            border-radius: 0 0 15px 15px;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2.5rem;
            }
            
            .subtitle {
                font-size: 1.2rem;
            }
            
            .content {
                padding: 15px;
            }
            
            .feature-card, .description, .code-preview, .shader-controls {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <canvas id="webgl-canvas"></canvas>
        
        <div class="content">
            <header>
                <h1>INFINITE NOVEL</h1>
                <p class="subtitle">An AI-Powered Interactive Narrative Experience with Quantum Neural Networks</p>
                <a href="https://github.com/0penAGI/InfiniteNovel/tree/main" class="github-link" target="_blank">
                    <i class="fab fa-github"></i> View on GitHub
                </a>
            </header>
            
            <section class="description">
                <h2>About the Project</h2>
                <p>Infinite Novel is a cutting-edge interactive storytelling game that combines AI generation, quantum-inspired neural networks, and real-time visual effects. The game creates a dynamic narrative that evolves based on player input, with AI-generated images, voice synthesis, and adaptive music.</p>
                <p>The system uses Stable Diffusion for image generation, TTS for voice synthesis, and a custom Quantum Neural Network with Fractal Memory to create a truly responsive and immersive experience.</p>
            </section>
            
            <section class="features">
                <div class="feature-card">
                    <h3><i class="fas fa-brain"></i> Quantum Neural Network</h3>
                    <p>A custom neural network with quantum-inspired layers that adapts to player choices and creates emergent narrative patterns.</p>
                </div>
                
                <div class="feature-card">
                    <h3><i class="fas fa-image"></i> AI Image Generation</h3>
                    <p>Real-time Stable Diffusion integration generates cinematic visuals that respond to the narrative and player actions.</p>
                </div>
                
                <div class="feature-card">
                    <h3><i class="fas fa-microphone"></i> Voice Synthesis</h3>
                    <p>TTS with HiFi-GAN vocoder creates dynamic voice responses for all narrative elements and characters.</p>
                </div>
                
                <div class="feature-card">
                    <h3><i class="fas fa-infinity"></i> Fractal Memory</h3>
                    <p>Advanced memory system that maintains narrative coherence across sessions with LSTM and quantum layers.</p>
                </div>
                
                <div class="feature-card">
                    <h3><i class="fas fa-music"></i> Adaptive Music</h3>
                    <p>Procedurally generated music that evolves based on story progress, mood, and player resonance.</p>
                </div>
                
                <div class="feature-card">
                    <h3><i class="fas fa-code-branch"></i> Dynamic Story Arcs</h3>
                    <p>Four story arcs (Awakening, Convergence, Rupture, Synthesis) that change based on player impact and choices.</p>
                </div>
            </section>
            
            <div class="tech-stack">
                <span class="tech-tag">PyGame</span>
                <span class="tech-tag">PyTorch</span>
                <span class="tech-tag">Stable Diffusion</span>
                <span class="tech-tag">Transformers</span>
                <span class="tech-tag">TTS</span>
                <span class="tech-tag">OpenCV</span>
                <span class="tech-tag">NumPy</span>
                <span class="tech-tag">Quantum ML</span>
                <span class="tech-tag">WebGL</span>
                <span class="tech-tag">Gemma 3</span>
            </div>
            
            <section class="code-preview">
                <h2>Core Architecture</h2>
                <pre class="code-snippet"><code>class <span class="code-keyword">QuantumNeuralNetwork</span>(nn.Module):
    <span class="code-comment"># Quantum-inspired neural network for narrative adaptation</span>
    def __init__(self, input_size=10, hidden_size=20):
        super().__init__()
        self.fc1 = nn.Linear(input_size, hidden_size)
        self.fc2 = nn.Linear(hidden_size, input_size)
        self.quantum_weights = torch.randn(hidden_size, requires_grad=True)

    def forward(self, x):
        x = torch.relu(self.fc1(x))
        <span class="code-comment"># Quantum layer with wave function behavior</span>
        quantum_layer = x * torch.cos(self.quantum_weights) + torch.sin(self.quantum_weights)
        return self.fc2(quantum_layer)

class <span class="code-keyword">FractalMemory</span>(nn.Module):
    <span class="code-comment"># LSTM with quantum layers for narrative memory</span>
    def __init__(self, input_size=10, hidden_size=20):
        super().__init__()
        self.lstm = nn.LSTM(input_size, hidden_size, batch_first=True)
        self.quantum = QuantumNeuralNetwork(hidden_size, hidden_size)
        self.fc = nn.Linear(hidden_size, input_size)</code></pre>
            </section>
            
            <section class="shader-controls">
                <h2>Shader Controls</h2>
                <p>Adjust the WebGL shader parameters to match the mood of your Infinite Novel experience.</p>
                
                <div class="control-group">
                    <div class="control-item">
                        <label for="pulseSpeed">Pulse Speed</label>
                        <input type="range" id="pulseSpeed" min="0.1" max="5" value="1.5" step="0.1">
                    </div>
                    
                    <div class="control-item">
                        <label for="distortion">Distortion Intensity</label>
                        <input type="range" id="distortion" min="0" max="2" value="0.8" step="0.1">
                    </div>
                    
                    <div class="control-item">
                        <label for="glow">Glow Intensity</label>
                        <input type="range" id="glow" min="0" max="3" value="1.2" step="0.1">
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="control-item">
                        <label for="colorShift">Color Shift</label>
                        <input type="range" id="colorShift" min="0" max="2" value="0.5" step="0.1">
                    </div>
                    
                    <div class="control-item">
                        <label for="fractalDepth">Fractal Depth</label>
                        <input type="range" id="fractalDepth" min="1" max="10" value="4" step="1">
                    </div>
                    
                    <div class="control-item">
                        <label for="brightness">Brightness</label>
                        <input type="range" id="brightness" min="0.1" max="2" value="1" step="0.1">
                    </div>
                </div>
                
                <div class="preset-buttons">
                    <button class="preset-btn" data-preset="awakening">Awakening Arc</button>
                    <button class="preset-btn" data-preset="convergence">Convergence Arc</button>
                    <button class="preset-btn" data-preset="rupture">Rupture Arc</button>
                    <button class="preset-btn" data-preset="synthesis">Synthesis Arc</button>
                    <button class="preset-btn" data-preset="quantum">Quantum State</button>
                    <button class="preset-btn" data-preset="reset">Reset</button>
                </div>
            </section>
            
            <footer>
                <p>Infinite Novel - An OpenAGI Project | WebGL Visualization</p>
                <p>Experience the fusion of quantum computing, AI, and interactive storytelling</p>
            </footer>
        </div>
    </div>

    <script type="x-shader/x-vertex" id="vertexShader">
        attribute vec3 aPosition;
        attribute vec2 aTexCoord;
        
        varying vec2 vTexCoord;
        varying vec3 vPosition;
        
        void main() {
            vTexCoord = aTexCoord;
            vPosition = aPosition;
            gl_Position = vec4(aPosition, 1.0);
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentShader">
        precision highp float;
        
        varying vec2 vTexCoord;
        varying vec3 vPosition;
        
        uniform float uTime;
        uniform float uPulseSpeed;
        uniform float uDistortion;
        uniform float uGlow;
        uniform float uColorShift;
        uniform float uFractalDepth;
        uniform float uBrightness;
        
        // Fractal noise function
        float fractalNoise(vec2 p, int octaves) {
            float value = 0.0;
            float amplitude = 0.5;
            float frequency = 1.0;
            float maxValue = 0.0;
            
            for(int i = 0; i < 10; i++) {
                if(i >= octaves) break;
                
                // Rotating noise for more organic feel
                vec2 q = vec2(
                    cos(p.x * frequency + uTime * 0.1) - sin(p.y * frequency + uTime * 0.1),
                    sin(p.x * frequency + uTime * 0.1) + cos(p.y * frequency + uTime * 0.1)
                );
                
                value += amplitude * (sin(q.x * 10.0) * 0.5 + 0.5) * (cos(q.y * 10.0) * 0.5 + 0.5);
                maxValue += amplitude;
                amplitude *= 0.5;
                frequency *= 2.0;
            }
            
            return value / maxValue;
        }
        
        // Quantum wave function simulation
        float quantumWave(vec2 p, float time) {
            return sin(p.x * 5.0 + time) * cos(p.y * 3.0 + time * 0.7) * 
                   sin(p.x * p.y * 2.0 + time * 0.3) * cos(p.x * 7.0 - time * 0.5);
        }
        
        // Color palette for different story arcs
        vec3 getArcColor(float arc, vec2 uv) {
            if(arc < 0.25) {
                // Awakening - blues and purples
                return vec3(0.1, 0.3, 0.8) + vec3(0.5, 0.2, 0.6) * sin(uv.x * 10.0 + uTime);
            } else if(arc < 0.5) {
                // Convergence - golds and oranges
                return vec3(0.8, 0.6, 0.1) + vec3(0.3, 0.2, 0.1) * cos(uv.y * 8.0 + uTime * 0.7);
            } else if(arc < 0.75) {
                // Rupture - reds and dark purples
                return vec3(0.7, 0.1, 0.3) + vec3(0.3, 0.0, 0.4) * sin(uv.x * uv.y * 20.0 + uTime * 1.2);
            } else {
                // Synthesis - greens and cyans
                return vec3(0.1, 0.7, 0.5) + vec3(0.2, 0.3, 0.8) * cos(uv.x * 6.0 - uv.y * 6.0 + uTime * 0.9);
            }
        }
        
        void main() {
            // Normalized coordinates with aspect ratio correction
            vec2 uv = vTexCoord * 2.0 - 1.0;
            uv.x *= 1.0; // Aspect ratio
            
            // Time with pulse speed
            float time = uTime * uPulseSpeed * 0.001;
            
            // Create distortion
            vec2 distortedUV = uv;
            distortedUV.x += sin(uv.y * 3.0 + time * 1.5) * 0.1 * uDistortion;
            distortedUV.y += cos(uv.x * 2.0 + time * 1.2) * 0.1 * uDistortion;
            
            // Generate fractal patterns
            float fractal = fractalNoise(distortedUV * uFractalDepth, int(uFractalDepth));
            
            // Quantum interference patterns
            float quantum = quantumWave(distortedUV * 2.0, time) * 0.5 + 0.5;
            
            // Neural network connections visualization
            float neural = sin(distortedUV.x * 20.0 + time) * cos(distortedUV.y * 15.0 + time) * 0.5 + 0.5;
            
            // Combine patterns
            float pattern = mix(fractal, quantum, 0.5) * neural;
            
            // Pulsating core
            float pulse = sin(time * 2.0) * 0.5 + 0.5;
            float distanceFromCenter = length(uv);
            float core = (1.0 - smoothstep(0.0, 0.5, distanceFromCenter)) * pulse;
            
            // Create main color
            vec3 color = getArcColor(pattern, uv) * (pattern * 0.8 + core * 0.4);
            
            // Apply color shifting
            color.r = mix(color.r, color.g, uColorShift * 0.3);
            color.g = mix(color.g, color.b, uColorShift * 0.3);
            color.b = mix(color.b, color.r, uColorShift * 0.3);
            
            // Add glow effect
            vec3 glowColor = vec3(0.5, 0.3, 0.8) * uGlow;
            color += glowColor * (pattern * 0.5 + core * 0.3);
            
            // Brightness adjustment
            color *= uBrightness;
            
            // Final output with vignette
            float vignette = 1.0 - distanceFromCenter * 0.5;
            color *= vignette;
            
            gl_FragColor = vec4(color, 1.0);
        }
    </script>

    <script>
        // WebGL initialization
        const canvas = document.getElementById('webgl-canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        
        if (!gl) {
            alert('WebGL not supported!');
            throw new Error('WebGL not supported');
        }
        
        // Set canvas size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // Compile shader
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }
        
        // Create program
        const vertexShader = compileShader(document.getElementById('vertexShader').textContent, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(document.getElementById('fragmentShader').textContent, gl.FRAGMENT_SHADER);
        
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program linking error:', gl.getProgramInfoLog(program));
        }
        
        gl.useProgram(program);
        
        // Create geometry (fullscreen quad)
        const vertices = new Float32Array([
            -1, -1, 0,  0, 0,
             1, -1, 0,  1, 0,
            -1,  1, 0,  0, 1,
             1,  1, 0,  1, 1
        ]);
        
        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        
        // Set up attributes
        const positionAttrib = gl.getAttribLocation(program, 'aPosition');
        const texCoordAttrib = gl.getAttribLocation(program, 'aTexCoord');
        
        gl.enableVertexAttribArray(positionAttrib);
        gl.enableVertexAttribArray(texCoordAttrib);
        
        gl.vertexAttribPointer(positionAttrib, 3, gl.FLOAT, false, 20, 0);
        gl.vertexAttribPointer(texCoordAttrib, 2, gl.FLOAT, false, 20, 12);
        
        // Get uniform locations
        const timeUniform = gl.getUniformLocation(program, 'uTime');
        const pulseSpeedUniform = gl.getUniformLocation(program, 'uPulseSpeed');
        const distortionUniform = gl.getUniformLocation(program, 'uDistortion');
        const glowUniform = gl.getUniformLocation(program, 'uGlow');
        const colorShiftUniform = gl.getUniformLocation(program, 'uColorShift');
        const fractalDepthUniform = gl.getUniformLocation(program, 'uFractalDepth');
        const brightnessUniform = gl.getUniformLocation(program, 'uBrightness');
        
        // Set initial uniform values
        let uniforms = {
            pulseSpeed: 1.5,
            distortion: 0.8,
            glow: 1.2,
            colorShift: 0.5,
            fractalDepth: 4,
            brightness: 1.0
        };
        
        // Update uniforms from UI controls
        function updateUniforms() {
            gl.uniform1f(pulseSpeedUniform, uniforms.pulseSpeed);
            gl.uniform1f(distortionUniform, uniforms.distortion);
            gl.uniform1f(glowUniform, uniforms.glow);
            gl.uniform1f(colorShiftUniform, uniforms.colorShift);
            gl.uniform1f(fractalDepthUniform, uniforms.fractalDepth);
            gl.uniform1f(brightnessUniform, uniforms.brightness);
        }
        
        // Connect UI controls
        document.getElementById('pulseSpeed').addEventListener('input', (e) => {
            uniforms.pulseSpeed = parseFloat(e.target.value);
            updateUniforms();
        });
        
        document.getElementById('distortion').addEventListener('input', (e) => {
            uniforms.distortion = parseFloat(e.target.value);
            updateUniforms();
        });
        
        document.getElementById('glow').addEventListener('input', (e) => {
            uniforms.glow = parseFloat(e.target.value);
            updateUniforms();
        });
        
        document.getElementById('colorShift').addEventListener('input', (e) => {
            uniforms.colorShift = parseFloat(e.target.value);
            updateUniforms();
        });
        
        document.getElementById('fractalDepth').addEventListener('input', (e) => {
            uniforms.fractalDepth = parseFloat(e.target.value);
            updateUniforms();
        });
        
        document.getElementById('brightness').addEventListener('input', (e) => {
            uniforms.brightness = parseFloat(e.target.value);
            updateUniforms();
        });
        
        // Preset configurations
        const presets = {
            awakening: { pulseSpeed: 1.0, distortion: 0.5, glow: 0.8, colorShift: 0.3, fractalDepth: 3, brightness: 0.9 },
            convergence: { pulseSpeed: 1.8, distortion: 0.7, glow: 1.5, colorShift: 0.6, fractalDepth: 5, brightness: 1.1 },
            rupture: { pulseSpeed: 2.5, distortion: 1.5, glow: 2.0, colorShift: 0.8, fractalDepth: 7, brightness: 1.3 },
            synthesis: { pulseSpeed: 1.2, distortion: 0.3, glow: 1.0, colorShift: 0.4, fractalDepth: 4, brightness: 1.0 },
            quantum: { pulseSpeed: 3.0, distortion: 2.0, glow: 2.5, colorShift: 1.5, fractalDepth: 8, brightness: 1.5 },
            reset: { pulseSpeed: 1.5, distortion: 0.8, glow: 1.2, colorShift: 0.5, fractalDepth: 4, brightness: 1.0 }
        };
        
        // Apply presets
        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const preset = presets[btn.dataset.preset];
                uniforms = { ...preset };
                
                // Update UI sliders
                document.getElementById('pulseSpeed').value = uniforms.pulseSpeed;
                document.getElementById('distortion').value = uniforms.distortion;
                document.getElementById('glow').value = uniforms.glow;
                document.getElementById('colorShift').value = uniforms.colorShift;
                document.getElementById('fractalDepth').value = uniforms.fractalDepth;
                document.getElementById('brightness').value = uniforms.brightness;
                
                updateUniforms();
            });
        });
        
        // Animation loop
        let startTime = Date.now();
        
        function animate() {
            const currentTime = Date.now() - startTime;
            gl.uniform1f(timeUniform, currentTime);
            
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            requestAnimationFrame(animate);
        }
        
        // Start animation
        updateUniforms();
        animate();
        
        // Add some interactive effects on mouse move
        let mouseX = 0.5, mouseY = 0.5;
        
        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX / window.innerWidth;
            mouseY = 1.0 - e.clientY / window.innerHeight;
            
            // Optional: Add mouse interaction to shader
            // You could add mouse uniforms and use them in the shader
        });
        
        // GitHub link opens in new tab
        document.querySelector('.github-link').addEventListener('click', (e) => {
            e.preventDefault();
            window.open(e.target.href || e.target.parentElement.href, '_blank');
        });
    </script>
</body>
</html>
